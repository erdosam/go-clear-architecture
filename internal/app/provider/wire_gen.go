// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package provider

import (
	"fmt"
	"github.com/casbin/casbin/v2"
	"github.com/erdosam/go-clear-architecture/config"
	"github.com/erdosam/go-clear-architecture/internal/controller/http/middleware"
	"github.com/erdosam/go-clear-architecture/internal/controller/http/v1"
	"github.com/erdosam/go-clear-architecture/internal/controller/pubsub"
	"github.com/erdosam/go-clear-architecture/internal/usecase"
	"github.com/erdosam/go-clear-architecture/internal/usecase/dao"
	"github.com/erdosam/go-clear-architecture/pkg/httpserver"
	"github.com/erdosam/go-clear-architecture/pkg/logger"
	"github.com/erdosam/go-clear-architecture/pkg/messaging"
	"github.com/erdosam/go-clear-architecture/pkg/postgres"
	"github.com/erdosam/go-clear-architecture/pkg/storage"
	"github.com/go-playground/validator/v10"
	"github.com/google/wire"
	"log"
	"sync"
)

// Injectors from wire.go:

func NewRepo() *postgres.Postgres {
	config := provideSingletonConfig()
	loggerInterface := NewLogger()
	postgresPostgres := provideSingletonRepository(config, loggerInterface)
	return postgresPostgres
}

func NewLogger() logger.Interface {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	return loggerInterface
}

func NewHttpServer() *httpserver.Server {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	ping := newPingUsecase()
	feature := provideFeatures(ping)
	authentication := newAuthenticationMiddleware()
	authorization := newAuthorizationMiddleware()
	middleware := provideMiddlewares(authentication, authorization)
	handler := v1.NewRouterHandler(loggerInterface, feature, middleware)
	v := provideServerOptions(config)
	server := httpserver.New(handler, v...)
	return server
}

func NewPubsubSubscriber() *pubsub.SubscriptionHandler {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	messagingPubsub := provideSingletonPubsub(loggerInterface, config)
	subscriptionHandler := pubsub.NewSubscriptionsHandler(loggerInterface, messagingPubsub)
	return subscriptionHandler
}

func NewCloudStorage() storage.Storage {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	storageStorage := provideSingletonStorage(loggerInterface, config)
	return storageStorage
}

func NewCloudMessaging() messaging.Pubsub {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	messagingPubsub := provideSingletonPubsub(loggerInterface, config)
	return messagingPubsub
}

func newAuthenticationMiddleware() middleware.Authentication {
	user := newUserUseCase()
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	authentication := middleware.NewJwtAuthentication(user, loggerInterface, config)
	return authentication
}

func newAuthorizationMiddleware() middleware.Authorization {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	authorization := middleware.NewAbacAuthorization(config, loggerInterface)
	return authorization
}

func newUserUseCase() usecase.User {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	postgresPostgres := provideSingletonRepository(config, loggerInterface)
	userDAO := newSingletonUserDAO(loggerInterface, postgresPostgres)
	user := usecase.NewUserUseCase(loggerInterface, userDAO)
	return user
}

func newPingUsecase() usecase.Ping {
	config := provideSingletonConfig()
	loggerInterface := provideSingletonLogger(config)
	messagingPubsub := provideSingletonPubsub(loggerInterface, config)
	ping := usecase.NewPingUsecase(messagingPubsub)
	return ping
}

// wire.go:

type singletons struct {
	config   *config.Config
	log      logger.Interface
	db       *postgres.Postgres
	enforcer *casbin.Enforcer
	userDAO  dao.UserDAO
	pubsub   messaging.Pubsub
	storage  storage.Storage
	once     struct {
		config   sync.Once
		log      sync.Once
		db       sync.Once
		userDAO  sync.Once
		enforcer sync.Once
		pubsub   sync.Once
		storage  sync.Once
	}
}

var (
	s singletons
	// component dependencies
	commonSet = wire.NewSet(
		provideSingletonConfig,
		provideSingletonLogger,
		provideSingletonRepository,
		provideValidator,
		provideSingletonPubsub,
		provideSingletonStorage,
	)
	daoSet = wire.NewSet(
		newSingletonUserDAO,
	)
	middlewareSet = wire.NewSet(
		newAuthenticationMiddleware,
		newAuthorizationMiddleware,
		provideMiddlewares,
	)
	featureSet = wire.NewSet(
		newPingUsecase,
		provideFeatures,
	)
)

func provideFeatures(ping usecase.Ping) *v1.Feature {
	return &v1.Feature{
		Ping: ping,
	}
}

func provideMiddlewares(a1 middleware.Authentication, a2 middleware.Authorization) *v1.Middleware {
	return &v1.Middleware{
		Authentication: a1,
		Authorization:  a2,
	}
}

func provideValidator() *validator.Validate {
	return validator.New(validator.WithRequiredStructEnabled())
}

func provideSingletonConfig() *config.Config {
	s.once.config.Do(func() {
		conf, err := config.NewConfig()
		if err != nil {
			log.Fatalf("Config error: %s", err)
		}
		s.config = conf
	})
	return s.config
}

func provideSingletonLogger(cfg *config.Config) logger.Interface {
	s.once.log.Do(func() {
		s.log = logger.New(cfg.Log.Level)
	})
	return s.log
}

func provideSingletonRepository(cfg *config.Config, l logger.Interface) *postgres.Postgres {
	s.once.db.Do(func() {
		pg, err := postgres.New(cfg.PG.URL)
		if err != nil {
			l.Fatal(fmt.Errorf("app.Run: %w", err))
		}
		s.db = pg
	})
	return s.db
}

func provideSingletonPubsub(l logger.Interface, cfg *config.Config) messaging.Pubsub {
	s.once.pubsub.Do(func() {
		s.pubsub = messaging.NewPubsub(cfg, l)
	})
	return s.pubsub
}

func provideSingletonStorage(l logger.Interface, cfg *config.Config) storage.Storage {
	s.once.storage.Do(func() {
		s.storage = storage.New(l, cfg)
	})
	return s.storage
}

func provideServerOptions(cfg *config.Config) []httpserver.Option {
	return []httpserver.Option{httpserver.Port(cfg.HTTP.Port)}
}

func newSingletonUserDAO(l logger.Interface, pg *postgres.Postgres) dao.UserDAO {
	s.once.userDAO.Do(func() {
		s.userDAO = dao.NewUserDAO(l, pg)
	})
	return s.userDAO
}
